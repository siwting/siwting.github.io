## 不要直接操作 DOM

Angular 不再是简单的 Web 框架，Angular 是一个平台，它的一个优点是允许我们将应用程序代码与渲染器分离，从而编写可以在浏览器、服务器上运行的应用程序，甚至可以编写原生应用。

此外解耦后，也为我们提供更多的能力，如使用 AOT (Ahead of time) 或 Web Worker。AOT 意味着在构建阶段进行模板编译，AOT 编译模式的开发流程：

- 使用 TypeScript 开发 Angular 应用

- 运行 ngc 编译应用程序

- 使用 Angular Compiler 编译模板，一般输出 TypeScript 代码

- 运行 tsc 编译 TypeScript 代码

- 使用 Webpack 或 Gulp 等其他工具构建项目，如代码压缩、合并等

- 部署应用

除此之外 AOT 还有以下优点：

- 在客户端我们不需要导入体积庞大的 angular 编译器，这样可以减少我们 JavaScript 脚本库的大小

- 使用 AOT 编译后的应用，不再包含任何 HTML 片段，取而代之的是编译生成的 TypeScript 代码，这样的话 TypeScript 编译器就能提前发现错误。总而言之，采用 AOT 编译模式，我们的模板是类型安全的。

如果我们现在或将来要使用这种功能，我们需要遵守一定的规则。其中一个规则是不能使用 jQuery，document 对象或 ElementRef.nativeElement 来直接操作 DOM。具体示例如下：

``` js

@Component({ ... })
export class HeroComponent {
  constructor(private _elementRef: ElementRef) {}

  doBadThings() {
    $('.bad-with-jquery').click();
    this._elementRef.nativeElement.xyz = 'bad with native element';
    document.getElementById('bad-with-document');
  }
}

```

## 正确的使用方式

在 Angular 中我们推荐通过 Renderer2 服务执行 DOM 操作 (Angular 2 中使用 Renderer)。

``` js

@Component({ ... })
export class HeroComponent {
  constructor(
    private _renderer2: Renderer2,
    private _elementRef: ElementRef) {}

  doGoodThings() {
    this._renderer2.setElementProperty(this._elementRef,
      'some-property', true);
  }
}

```

> 上面代码中，我们通过依赖注入方式注入 Renderer2 和 ElementRef 实例，然后在 doGoodThings() 方法中调用 Renderer2 实例提供的 setElementProperty() 方法来设置元素的属性。 此外，为了方便开发者获取视图中的元素，Angular 为我们提供了 @ViewChild、@ViewChildren、@ContentChild 和 @ContentChildren 等装饰器。

渲染器是视图层的封装。当我们在浏览器中时，将使用默认渲染器。当应用程序在不同平台 (如 WebWorker ) 上运行时，渲染器将被替换为平台对应的渲染器。此渲染器需要实现 Renderer2 抽象类，并利用 DI (依赖注入) 机制作为默认的 Renderer 对象注入到组件或服务中。
