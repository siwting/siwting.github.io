### 1. 单元测试流程

**1.1 导入相关的jar包**

  - Gradle 项目在build.gradle导入测试依赖，${springVersion}在build.gradle中已配置：
  ```
  testCompile 'junit:junit:4.12'
  testCompile("org.springframework:spring-test:${springVersion}")
  testCompile 'com.jayway.jsonpath:json-path:2.2.0'
  testCompile 'com.jayway.jsonpath:json-path-assert:2.2.0'
  testCompile 'org.mockito:mockito-core:2.7.22'
  ```
  - eclipse项目：将相应的jar包拷贝至WEB-INF的lib目录  
    到[maven仓库](https://mvnrepository.com/)搜索junit、spring-test、json-path、json-path-assert和mockito-core，下载相应版本即可。

**1.2 创建test目录**
    - Gradle项目  
      在src目录下添加test目录（与main同级），设置test目录为Test Source Root，如图所示  
      ![目录](amWiki/images/directory.jpg "Title")
    - eclipse项目则与src同级创建test目录

**1.3 创建action和service的测试基类**

    一个项目创建一个测试基类即可。  

    ```java  
    @RunWith(SpringJUnit4ClassRunner.class)  // 调用Spring单元测试类
    @WebAppConfiguration // 调用java web组件
    @ContextConfiguration({"classpath*:spring-config.xml", "classpath*:rest-config.xml"})  // 加载spring配置文件
    public class ActionBaseTest {
      @Autowired
      private WebApplicationContext webApplicationContext;

      protected MockMvc mockMvc;

      @Before
      public void setup() {
          this.mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();
    }
    ```
    ```java
    @RunWith(SpringJUnit4ClassRunner.class)
    @ContextConfiguration({"classpath*:spring-config.xml", "classpath*:rest-config.xml"})
    //@Transactional
    public class ServiceBaseTest {
    }
    ```
    说明：
    - `@RunWith(SpringJunit4ClassRunner.class)`：表示使用Spring Test组件进行单元测试，使得组件可以采用注解依赖输入
    - `@WebAppConfiguration`：此注解可以调用Controller的相关组件
    - `@ContextConfiguration` : 加载Spring组件的配置文件
    - `@Transactional`：对测试用例进行事务管理

**1.4 创建测试类**

    - 在controller、service层的实现类的名称上按`alter + enter`，在弹出的菜单中选择`create test`，进入创建test的页面，选择需要测试的方法，生成框架代码。  
    ![create test](amWiki/images/create test.jpg)
    - 类的每个方法只会生成一个测试方法，针对方法的业务逻辑需要手动编写多个测试方法
    - 每个测试类需要继承相应的测试基类

**1.5 编写测试代码**

    编写测试代码的原则：  

    - 测试数据尽可能外部化，而不是硬编码
    - 使用断言而不是print语句进行结果验证
    - 第三方请求必须使用mock模拟，禁止直接调用
    - 构建具有确定性结果的测试  

  测试代码主要包括：构造测试数据、模拟请求、验证结果等三个方面。
  
    - 构造测试数据：测试数据应该是人造的，不是从环境数据dump一份
    - 模拟请求：action的http请求采用perform方法发送请求，第三方请求模拟采用Mockito的`when...thenReturn`方法
    - 验证结果：  
      - 注意验证的强度，验证关键数据的正确性
      - mvc采用`andExpect`或`assertXxx`方法验证，采用jsonpath验证json字段
      - Mockito采用`assertXxx`和`verify`方法验证

  ```java
  // action请求的测试
  @Test
  public void getContactCorrect() throws Exception {
      MvcResult mvcResult = this.mockMvc.perform(
              post("/wxb/contact/get/" + correctId)
                      .characterEncoding("utf-8")
                      .contentType(MediaType.APPLICATION_JSON)
                      .accept(MediaType.APPLICATION_JSON))  // 执行请求
              .andExpect(status().isOk()) // 验证状态码
              .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8_VALUE)) // 验证响应contentType
              .andExpect(jsonPath("$.code").value(CoreErrorCode.SUCCESS_CODE.getCode())) // 使用Json path验证JSON
              .andExpect(jsonPath("$.msg").value(CoreErrorCode.SUCCESS_CODE.getMsg())) // 使用Json path验证JSON
              .andExpect(jsonPath("$.data.devCode").value("864944030468387"))
              .andDo(MockMvcResultHandlers.print())
              .andReturn();

      // 验证结果的第二种方式：assertXxx
      String result = mvcResult.getResponse().getContentAsString();
      ReturnMsg msg = JSONHelper.jsonToBean(result, ReturnMsg.class);
      assertNotNull(msg);
      assertEquals(CoreErrorCode.SUCCESS_CODE.getCode(), msg.getCode());
      assertEquals(CoreErrorCode.SUCCESS_CODE.getMsg(), msg.getMsg());
  }
  ```
  ```java
  // service层，数据库请求，直接调用测试数据库
  @Test
  public void findList() throws Exception {
      // 1. 模拟参数
      Question question = new Question();
      Pagination pagination = new Pagination();
      pagination.setLimit(10);
      pagination.setOffset(0);

      question.setAgentId("oAvcAwGzw4tBmlIJVkt_Zt9rf7AY");
      question.setPagination(pagination);

      // 2. 调用方法
      List<Question> questions = questionService.findList(question);

      // 3. 验证结果
      assertNotNull(questions);
      assertEquals(10, questions.size());
  }
  ```
  ```java
  // 第三方请求，需要通过Mockito进行mock
  @InjectMocks
    private WxbContactAction contactAction;

    @Mock
    private WxbContactService contactService;

    @Before
    public void setup() {
        MockitoAnnotations.initMocks(this);
        this.mockMvc = MockMvcBuilders.standaloneSetup(contactAction).build();
    }
    // 请求异常
    @Test(expected = Exception.class)
    public void getContactCatch() throws Exception {
        // 1. 测试数据
        String id = "18771cbc-78f6-11e7-b9bf-0017fa008d45";
        // 2. mock
        when(contactService.getById(id))
                .thenThrow(new GlobalException(CoreErrorCode.QUERY_WATCH_CONTACT_EXCEPTION));
        // 3. 发送请求并验证
        this.mockMvc.perform(
                post("/wxb/contact/get/" + id)
                        .characterEncoding("utf-8")
                        .contentType(MediaType.APPLICATION_JSON)
                        .accept(MediaType.APPLICATION_JSON))// 执行请求
                .andExpect(status().isOk()) // 验证状态码
                .andExpect(jsonPath("$.code").value(CoreErrorCode.QUERY_WATCH_CONTACT_EXCEPTION.getCode())) // 使用Json path验证JSON
                .andExpect(jsonPath("$.msg").value(CoreErrorCode.QUERY_WATCH_CONTACT_EXCEPTION.getMsg()))
                .andDo(MockMvcResultHandlers.print())
                .andReturn();
        // 4. 验证mock是否执行
        verify(contactService, times(1)).getById(id);
        verifyNoMoreInteractions(this.contactService);

    }
  ```

### 2. 代码demo

参见iguard的health项目提交的test

### 3. 参数化测试

待续...

### 4. 测试结果可视化

待续...
